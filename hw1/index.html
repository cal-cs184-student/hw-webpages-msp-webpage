<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Name: Michael Setchko Palmerlee</div>

		<br>

		Link to <a href="https://cal-cs184-student.github.io/hw-webpages-msp-webpage/hw1/index.html">webpage</a>
		
		<br>

		Link to <a href="https://github.com/cal-cs184-student/hw-webpages-msp-webpage">Github repository</a>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		To rasterize a triangle, I am essentially taking a sample at the center 
		of each pixel that is relevant to the triangle (inside its bounding box) 
		and testing to see if it is inside the triangle. I do this by performing 
		3 line tests which determines if the point is inside of an area where 
		the three half planes defined by the edges of the triangle intersect. If 
		the sample is inside of the triangle, that pixel is rendered with the color 
		of the triangle.
		<br/>
		<br/>

		I am ensuring that only samples within the bounding box of the triangle 
		are checked by taking the minimum x and y values of all of the vertices and 
		the maximum x and y values of all the vertices. I use these values as the 
		corner of the box from which I take samples. This makes it so I will always 
		sample the whole triangle but will not sample anything outside of the bounding 
		box.

		<br/>
		<br/>

		Here is an example rendering of the test4.svg file:
		
		<img src="img/test4.png" alt="test4" style="width:100%"/>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		For my supersampling algorithm, I first increased the size of the sample buffer 
		by a factor of the sampling rate so that it could hold all of the samples. 
		I added a helper function that would supersample a single pixel given an 
		input triangle. This loops through all the sample positions in the pixel 
		based on the sampling rate, and uses the same algorithm to sample each point. 
		It then saves each sample into the sample buffer. After all triangles and 
		lines have been supersampled and rasterized into the sample buffer, I average the samples 
		over each pixel and store this into the frame buffer. This gives us the 
		final antialiased image.

		<p>Examples of sampling rates 1, 4, and 16</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="img/sr1.png" width="400px"/>
				  <figcaption>Sampling rate 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/sr4.png" width="400px"/>
				  <figcaption>Sampling rate 4</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="img/sr16.png" width="400px"/>
				  <figcaption>Sampling rate 16</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		As the sampling rate increases, we get fewer jagged edges and disconnected
		pixels, because we are able to capture higher frequencies with our samples. 
		Then, we downsample to get an antialiased image.

		<h2>Task 3: Transforms</h2>
		<img src="img/cubeman.png" alt="test4" style="width:100%"/>

		In this image, I've modified cubeman using the transform functions I defined. 
		Here, cubeman is waving hello!

		<h2>Task 4: Barycentric coordinates</h2>
		My understanding of barycentric coordinates is a method of representing  
		interior points of a triangle as a linear combination of the three vertices. 
		We use variables \alpha, \beta, and \gamma represent the "weight" of each 
		of the three vertices in this combination.

		<p>Some examples:</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="img/tri_interp.png" width="400px"/>
				  <figcaption>Simple triangle with coloring based on barycentric coordinates</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/colors.png" width="400px"/>
				  <figcaption>Color wheel using barycentric interpolation</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling is when we sample for the color of each pixel, in this case 
		using a texture image. To use this to map the texture onto triangles 
		using the u, v coordinates assigned to each corner of the triangle. We can 
		interpolate u, v values across the triangle using barycentric coordinates. 
		We then sample the texture at the given u,v coordinates using either nearest 
		pixel or bilinear interpolation methods. For nearest pixel, we simply find 
		the nearest pixel to the u, v coordinate in the texture image. For bilinear 
		interpolation, we find the 4 nearest pixels in the texture image and use 
		these to get an interpolated color value. This estimates the color of the 
		exact u, v coordinate that we want to sample.

		<p>Examples of nearest pixel and bilinear interpolation</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="img/logo_nearest_1x.png" width="400px"/>
				  <figcaption>Nearest pixel, sampling rate 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/logo_nearest_16x.png" width="400px"/>
				  <figcaption>Nearest pixel, sampling rate 16</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="img/logo_bilinear_1x.png" width="400px"/>
				  <figcaption>Bilinear interpolation, sampling rate 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/logo_bilinear_16x.png" width="400px"/>
				  <figcaption>Bilinear interpolation, sampling rate 16</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<br/>

		Bilinear interpolation looks significantly more smooth and antialiased 
		than nearest pixel, even after 16x supersampling. This is because when we 
		are sampling textures at a given u, v coordinate, if this coordinate does 
		not exactly line up with a texel, nearest pixel is going to give us an 
		inaccurate representation of the color at that u, v coordinate, espeically 
		in high-frequency areas. Bilinear interpolation may also give us inaccurate 
		values, but they will likely be much more accurate because we are making 
		a better estimate using bilinear interpolation between 4 texels.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Level sampling uses several different "levels" of texture images which are 
		progressively downsampled. We calculate the level we want to use for a given 
		pixel by calculating the rate of change of u and v on the texture relative to 
		x and y in the screen pixel space. This allows us to map lower detail textures 
		to areas where the texture is very dense relative to the pixel size, effectively 
		decreasing the maximum frequency in order to more closely match the sampling rate. 
		There are a couple methods for determining which level of mipmap to use. 
		Nearest level simply rounds our value for the level to the nearest whole number, 
		whereas linear interpolation samples both levels above and below our calculated 
		level value and takes a weighted average of the two samples.

		<br/>

		For level sampling, always using level 0 is the fastest method but looks 
		the worst. Nearest level is slightly slower but with significantly improved 
		texture antialiasing, and linear interpolation is a bit slower with smoother 
		edges/fewer jaggies in the texture.

		<br/>

		Nearest pixel sampling gives significant aliasing in the texture. Bilinear 
		interpolation is a bit slower as it involves taking 4 samples per pixel and 
		doing 3 linear interpolations, but produces a much clearer image.

		<br/>

		Each increased level of supersampling gives an image that has better antialiasing 
		than the previous, although at 16x it seems to have diminishing returns. 
		Supersampling is slower due to needing to take multiple samples for each pixel 
		and also requires significantly more memory for the sample buffer.

		<p>Examples of nearest pixel and bilinear interpolation</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="img/L_zero_P_near.png" width="400px"/>
				  <figcaption>Level 0, nearest pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/L_zero_P_linear.png" width="400px"/>
				  <figcaption>Level 0, bilinear interpolated pixel</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="img/L_near_P_near.png" width="400px"/>
				  <figcaption>Nearest level, nearest pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/L_near_P_linear.png" width="400px"/>
				  <figcaption>Nearest level, bilinear interpolated pixel</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="img/L_linear_P_near.png" width="400px"/>
				  <figcaption>Linear interpolated level, bilinear interpolated pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/L_linear_P_linear.png" width="400px"/>
				  <figcaption>Trilinear filtering (linear level, bilinear pixel)</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		</div>
	</body>
</html>