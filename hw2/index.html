<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<br>
		
		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<figure>
			<img src="teapot.png" alt="Teapot" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		De Casteljau's algorithm is a method for evaluating a bezier curve over 
		an arbitrary number of control points. It achieves this by finding 
		intermediate points along the lines connecting the control points, and 
		then connecting these lines and repeating until there is only a single 
		point. To determine how far along each line we place the intermediate 
		point, we use a value  
		\( t \) with \( 0 \le t \le 1 \), where \( t \) is the proportional 
		distance along the connecting line. We can create a smooth curve by 
		iterating through possible t values at a desired resolution and 
		constructing a curve.

		<br/>
		<br/>

		I implemented this by completing the <code>evaluateStep()</code> function, 
		which performs a single step of the above algorithm. I did this by iterating 
		through the first n-1 input points (where there are n total points) and 
		performing a linear interpolation between each of these points and the 
		next point with parameter t from the class member variable. Then, I 
		return the vector of these n-1 interpolated points.

		<p>Here are some screenshots dsiplaying the functionality of the implementation:</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="img/level0.png" width="400px"/>
				  <figcaption>Just the control points with no interpolation</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/level1.png" width="400px"/>
				  <figcaption>Level 1 of de Casteljau</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="img/level2.png" width="400px"/>
				  <figcaption>Level 2 of de Casteljau</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/level3.png" width="400px"/>
				  <figcaption>Level 3 of de Casteljau</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="img/level4.png" width="400px"/>
				  <figcaption>Level 4 of de Casteljau</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/level5.png" width="400px"/>
				  <figcaption>Level 5 of de Casteljau</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="img/level5_curve.png" width="400px"/>
				  <figcaption>Level 5 of de Casteljau with bezier curve included</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/alt_curve.png" width="400px"/>
				  <figcaption>Level 5 with bezier curve on different control points</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		Implementing this part was fairly straightforward after completing the 
		previous step. To create a bezier surface from an \( n \times n \) matrix of control 
		points, I first ran de Casteljau's algorithm on each row of points using 
		the given \(u\) value, and then I ran de Casteljau's algorithm on this new 
		set of calculated points with the given \(v\) value. This finds a single point 
		on the bezier surface, and we can repeat this process with as many \(u,v\) 
		values as we like to interpolate a smooth bezier surface. Below is a 
		rendering of the teapot.bez file using my bezier surface implementation:

		<img src="img/teapot.png" width="600px"/>

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>
		To implement area weighted vertex normals, I first had to find all of the 
		faces connected to the vertex. I do this by getting a half edge associated 
		with the vertex. Then, I move through the half edges in a cycle of 
		next->next->twin, recording each half edge on the vertex until I have reached 
		the degree of the vertex. Once I have all of the half edges of a given 
		vertex, I will then loop through them all and take the cross product of 
		the half edge with its next half edge, to get a vector that is both normal 
		to the face and proportional to the area. I sum all of these normal vectors 
		together, and then normalize them to get the area weighted unit normal vector. 
		Below, we can this in use to create the illusion of a smooth surface through 
		shading based on normal vector interpolation.

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="img/teapot_standard.png" width="400px"/>
				  <figcaption>Teapot rendering without Phong shading</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/level1.png" width="400px"/>
				  <figcaption>Teapot rendering with Phong shading</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 4: Edge flip</h3>
		To implement edge flip, I first had to figure out exactly which mesh 
		elements would need to have their pointers updated, and which pointers would 
		need to point where. After drawing it out, I found that I just needed to 
		modify the two half edge loops such that the edge was flipped. I changed 
		the vertices pointed to by the two half edges of the flipped edge, and 
		then redirected the loops accordingly. I initially thought that this implementation 
		would work, but I started running into an issue when doing repeated flips: 
		faces started to disappear. After looking through all of the mesh element 
		classes again, I realized that I needed to reassign the half edge pointers 
		for the faces after rearranging the half edge loops to ensure that the 
		half edge pointed to by each face was accurate. After implementing this fix, 
		the flip function was fully working. Below is an image showing edges being 
		flipped on the teapot model.

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="img/edge_original.png" width="400px"/>
				  <figcaption>Teapot model with no edges flipped</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="img/edge_flipped.png" width="400px"/>
				  <figcaption>Teapot model with edges flipped</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 5: Edge split</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>